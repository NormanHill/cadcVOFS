#!python
"""A FUSE based filesystem view of VOSpace."""

from sys import argv, exit, platform
import time
from fuse import FUSE, Operations, FuseOSError, LoggingMixIn
import tempfile
from threading import Lock
from errno import EACCES, EIO, ENOENT, EISDIR, ENOTDIR, ENOTEMPTY, EPERM, EEXIST
import os
#from os import statvfs, fsync, write, read, lseek, close
import vos
from os import O_RDONLY, O_WRONLY, O_RDWR, O_APPEND
import logging

def flag2mode(flags):
    md = {O_RDONLY: 'r', O_WRONLY: 'w', O_RDWR: 'w+'}
    m = md[flags & (O_RDONLY | O_WRONLY | O_RDWR)]

    if flags | O_APPEND:
        m = m.replace('w', 'a', 1)

    return m


class VOFS(LoggingMixIn, Operations):
#class VOFS(Operations):
    """The VOFS filesystem opperations class.  Requires the vos (VOSpace) python package.

    To use this you will also need a VOSpace account from the CADC.
    """
    ### Currently disabled operations

    chown = None
    getxattr = None
    link = None
    listxattr = None
    mknode = None
    rename = None
    readlink = None
    rmdir = None
    symlink = None


    
    def __init__(self, root, cache_dir, conn=None, cache_limit=1024*1024*1024):
        self.node = {}
        self.attr={}
	self.path={}
        self.fobj={}
        self.fh={}
        self.fhlist=[]
        self.root = root
        self.cache_limit=cache_limit
        self.cache_dir = os.path.normpath(os.path.join(cache_dir,root))
        if not os.access(self.cache_dir,os.F_OK):
            os.makedirs(self.cache_dir)
        self.client = vos.Client(rootNode=root,conn=conn)
        #self.rwlock=Lock()

    def __call__(self, op, path, *args):
        return super(VOFS, self).__call__(op, path, *args)

    def __del__(self):
        self.node=None

    def setPath(self,fh,path):
        self.path[fh]=path

    def delPath(self,fh):
        self.path.pop(fh,None)

    def delNode(self,path):
        """Delete the references associated with this Node"""
        self.node.pop(path,None)
        self.attr.pop(path,None)

    def access(self, path, mode):
        self.getNode(path)

    def chmod(self, path, mode):
        logging.info("Changing mode for %s to %d" % ( path, mode))
        node = self.getNode(path)
        parent = self.getNode(os.path.dirname(path))
        if node.groupwrite == "NONE":
            node.groupwrite=parent.groupwrite
        if node.groupread == "NONE":
            node.groupread=parent.groupread
        fname=os.path.normpath(self.cache_dir+path)
        if os.access(fname,os.F_OK):
            os.chmod(fname,mode)
        if node.chmod(mode):
            self.client.update(node)
        
    def create(self, path, flags):
        """Create a node. Currently ignors the ownership mode"""
        logging.info("Creating a node: %s with mode %s" % (path, os.O_CREAT))
        self.client.open(path,os.O_CREAT).close()
        node = self.getNode(path)
        parent=  self.getNode(os.path.dirname(path))
        node.groupread = parent.groupread
        node.groupwrite = parent.groupwrite
        node.chmod(flags)
        self.client.update(node)
        fname=os.path.normpath(self.cache_dir+path)
        dirs=os.path.dirname(fname)
        if not os.path.exists(dirs):
            os.makedirs(dirs)
        fobj=open(fname,'w+b')
        fobj.truncate()
        os.chmod(fobj.name,flags)
        fd=fobj.fileno()
        self.fobj[fd]=fobj
	self.fh[fd]={'cached': 0, 'flags': O_RDWR, 'name': fname}
	self.setPath(fd, path)
        logging.info("Created node at %s and returning handle %d" % ( path, fd))
        return fd

    def flushnode(self,path,fh):
        """Flush the data associated with this fh to the Node at path."""
        os.fsync(fh)
        w=self.client.open(self.getNode(path).uri,'w')
        os.lseek(fh,0,0)
        bufsize=2**33
        while True:
            buf=os.read(fh,bufsize)
            logging.debug("Writing %d bytes to %s" % (len(buf), path))
            if not buf:
                break
            if w.write(buf)!=len(buf):
                raise FuseOSError(EIO)
        w.close()
        return


    def flush(self,path,fh):
        self.fsync(path,False,fh)
  
    def fsync(self,path,datasync,fh):
        if self.fh.get(fh,None):
            mode = flag2mode(self.fh[fh]['flags'])
        if 'w' in mode or 'a' in mode:
            try:
                os.fsync(fh)
                self.getattr(path)['st_mtime']=time.time()
            except:
                logging.critical("Failed to sync fh %d?" % ( fh))
                pass


    def getNode(self,path,force=False):
        logging.debug("requesting node %s" % ( path))
        if path in self.node and not force:
            logging.debug("Sending back chached node for %s" % ( path))
            return self.node[path]
        try:
            node=self.client.getNode(path)
        except IOError:
            raise FuseOSError(ENOENT)

        logging.debug("%s last modified at %s" % (path,time.ctime(node.attr.get('st_mtime'))))
        if path in self.node and node.attr.get('st_mtime') <= self.node[path].attr.get('st_mtime') :
                return self.node[path]
        logging.debug("Updating directory contents")
        self.node[path]=node
        for node in self.node[path].nodeList:
            npath=os.path.join(path,node.name)
            if node.isdir():
                ## get the container node XML file, caches child DataNode infos
                try:
                    self.node[npath]=self.client.getNode(node.uri)
                except IOError:
                    pass
            else:
                self.node[npath]=node
        return self.node[path]

    def getPath(self,fh):
        return self.path.get(fh,None)

    def getattr(self, path, fh=None):
	if not path in self.attr:
            node=self.getNode(path)
	    self.attr[path]=node.attr
            logging.debug("Got %s for %s" % (node, path))
        atime=self.attr.get('st_atime',time.time())
        mtime=self.attr.get('st_mtime',time.time())
        if not atime > mtime:
            logging.debug("Getting node details from getattr for path %s" % ( path))
	    self.attr[path].update(self.getNode(path).attr)
        return self.attr[path]

    def mkdir(self, path, mode):
        ### Need to implement the 'mode' part of this still...
        self.client.mkdir(path)
        self.chmod(path,mode)

    def open(self, path, flags, *mode):
	logging.debug("Openning %s with flags %s" % ( path, flag2mode(flags)))
        if len(mode)>0:
            logging.debug("got mode %s" % ( mode))
        #    self.chmod(path,mode)
        node=self.getNode(path)
        fname=os.path.normpath(self.cache_dir+path)
        dirs=os.path.dirname(fname)
        if not os.path.exists(dirs):
            os.makedirs(dirs)
        fobj=None
        if os.access(fname,os.R_OK):
            cache_stat=os.stat(fname)
            if not node.attr['st_mtime'] > cache_stat.st_mtime:
                fobj=open(fname,flag2mode(flags))
                fd=fobj.fileno()
                fobj.seek(0,os.SEEK_END)
                length=fobj.tell()
                fobj.seek(0)
                self.fh[fd]={'flags': flags, 'cached': length, 'name': fname}
        if fobj is None:
            fobj=open(fname,'w+b')
            fobj.truncate()
            fd=fobj.fileno()
            self.fh[fd]={'flags': flags, 'cached': 0, 'name': fname}
        self.fobj[fd]=fobj
        logging.debug("opened file %s and sent fd %d" % ( fname, fd))
	self.setPath(fd,path)
        return fd
    
    def read(self, path, size, offset, fh):
        """Read the entire file from the VOSpace server, place in a temporary file and then offset
        to the desired location"""
        ## Read from the requested filehandle, which the tempfile one sent from open
        logging.debug("Using fd %d",fh)
        #load the file from VOSpace as we might be appending
        os.lseek(fh,0,0)
        if self.fh[fh].get('cached',0)  < self.getattr(path)['st_size'] or os.stat(self.fh[fh]['name']).st_mtime < self.getattr(path)['st_mtime']:
          w=open(self.fh[fh]['name'],'wb')
          try:
            r=self.client.open(path,mode=os.O_RDONLY,view="data")
            fpos=0
            bufsize=2**33
            while True:
                buf=r.read(2**(10+10))
                logging.debug("Read buffer length %s from %s" % ( len(buf), self.getNode(self.getPath(fh)).name)) 
                if not buf:
                    break
                w.write(buf)
                logging.debug("wrote buffer to %s " % ( self.fh[fh]['name']))
                fpos=fpos+len(buf)
                #if fpos >= size+offset and size>0:
                #    break
            self.fh[fh]['cached']=fpos
            w.flush()
          except IOError as e:
            logging.error("%s" % ( e)) 
            raise FuseOSError(EACCES)
          finally:
            w.close()
            r.close()
        logging.debug("sending data from %d" % ( fh))
        os.lseek(fh,offset,0)
        return os.read(fh,size)

    def readdir(self, path, fh):
        return ['.','..'] + [e.name.encode('utf-8') for e in self.getNode(path,force=True).nodeList ]

    def release(self, path, fh):
        """Close the file, but if this was a holding spot for writes, then write the file to the node"""
        if self.fh.get(fh,None):
            mode = self.fh[fh]['flags']
            ### copy the staging file to VOSpace if needed
            logging.debug("node %s currently open with mode %s, releasing %d (%s)" % ( path, mode,fh, self.getPath(fh)))
            if mode & ( os.O_RDWR | os.O_WRONLY | os.O_APPEND | os.O_CREAT ):
                os.fsync(fh)
                w=self.client.open(path,os.O_WRONLY)
                os.lseek(fh,0,0)
                while True:
                    buf=os.read(fh,2**(10+10))
                    logging.debug("Writing %d bytes to %s" % (len(buf), path))
                    if not buf:
                        break
                    if w.write(buf)!=len(buf):
                        raise FuseOSError(EIO)
                w.close()

            ### remove the staging file from disk
            if self.fh[fh].get('name',None):
                #logging.debug("deleting the tmpfile %s" % (self.fh[fh]['name']))
                #os.unlink(self.fh[fh]['name'])
                self.fh.pop(fh,None)

        ## if we have an active file object then 
        ## close this file and forget about the pointer.
        if fh in self.fobj:
            logging.debug("checking if fh %d  is closed" % ( fh))
            if not self.fobj[fh].closed:
                logging.debug("Closing fh %d" % ( fh))
                ### Closing a bad handle doesn't hurt....
                try:
                    self.fobj[fh].close()
                except:
                    pass
            self.fobj.pop(fh,None)
        logging.debug("removing reference to %d" % ( fh) ) 
        self.delPath(fh)
        logging.debug("Deleting the Node from the lookup table")
        self.delNode(path)
        self.clear_cache()

    def cache_size(self):
        """Determine how much disk space is being used by the local cache"""
        import os
        start_path = self.cache_dir
        total_size = 0
        self.atimes={}
        oldest_time=time.time()
        for dirpath, dirnames, filenames in os.walk(start_path):
            for f in filenames:
                fp = os.path.join(dirpath, f)
                if oldest_time > os.stat(fp).st_atime and fp not in self.path.values():
                    oldest_time = os.stat(fp).st_atime
                    self.oldest_file = fp
                total_size += os.path.getsize(fp)
        return total_size

    def clear_cache(self):
        """Clear the oldest files until cache_size < cache_limit"""
        while ( self.cache_size() > self.cache_limit) :
            logging.info("Removing file %s from the local cache" % ( self.oldest_file))
            os.unlink(self.oldest_file)
            self.oldest_file=None

    def rmdir(self,path):
        node=self.getNode(path,force=True)
        #if not node.isdir():
        #    raise FuseOSError(ENOTDIR)
        #if len(node.nodeList)>0:
        #    raise FuseOSError(ENOTEMPTY)
        fname=os.path.normpath(self.cache_dir+path)
        if os.access(fname,os.F_OK):
	    os.rmdir(fname)
        self.client.delete(path)
        self.delNode(path)

        
    def statfs(self, path):
        node=self.getNode(path,force=False)
        block_size=512
        bytes=2**33
        free=2**33
        
        if 'quota' in node.props:
            bytes=int(node.props.get('quota',2**33))
            used=int(node.props.get('length',2**33))
            free=bytes-used
        sfs={}
        sfs['f_bsize']=block_size
        sfs['f_frsize']=block_size
        sfs['f_blocks']=int(bytes/block_size)
        sfs['f_bfree']=int(free/block_size)
        sfs['f_bavail']=int(free/block_size)
        sfs['f_files']=len(node.nodeList)
        sfs['f_ffree']=2*10
        sfs['f_favail']=2*10
        sfs['f_flags']=0
        sfs['f_namemax']=256
        return sfs
            
    
    def truncate(self, path, length, fh=None):
        logging.debug("Attempting to truncate %s (%d)" % ( path,length))
	if length>0:
            try:
                r = self.client.open(path,mode=os.O_RDONLY,view='data')
                w = self.client.open(path,os.O_WRONLY)
            except:
                raise FuseOSError(EIO)
            fpos=0
            bufsize=4096
            while True:
                buf=r.read(bufsize)
                if not buf:
                    break
                chunk=min(length-fpos,bufsize) 
                try: 
                    f.write(buf[:chunk])
                except:
                    raise FuseOSError(EIO)
                fpos=fpos+chunk
            r.close()
            w.close()
        else:
            self.client.open(path,os.O_WRONLY).close()
        #self.getattr(path)['st_size']=length
        #self.utimens(path)
        logging.debug("Node has been truncated")
	if fh is not None:
            os.ftruncate(fh,length)
        logging.debug("cache file has been truncated")

    def unlink(self,path):
        fname=os.path.normpath(self.cache_dir+path)
        if os.access(fname,os.F_OK):
            os.unlink(fname)
        self.client.delete(path)
        self.delNode(path)

    def utimens(self, path, times=None):
        if not times:
            t=time.time()
            times = (t,t)
        fname=os.path.normpath(self.cache_dir+path)
        if os.access(fname,os.F_OK):
            os.utime(path,times)
        self.getattr(path)['st_mtime']=times[1]
        self.getattr(path)['st_atime']=times[0]
        return 

    def write(self, path, data, offset, fh):
        os.lseek(fh, offset, 0)
        return os.write(fh, data)


if __name__ == "__main__":

    import optparse

    usage="%prog <root> <mountpoint>"

    parser=optparse.OptionParser(usage)

    parser.add_option("-d","--debug",action="store_true")
    parser.add_option("-v","--verbose",action="store_true")
    parser.add_option("-f","--foreground",action="store_true",help="Mount the filesystem as a foreground opperation and produce copious amounts of debuging information")
    parser.add_option("--log",action="store",help="File to store debug log to",default="/tmp/vos.err")
    parser.add_option("--cache_limit",action="store",type="int",help="upper limit on local diskspace to use for file caching",default=50*2**(10+10+10))
    parser.add_option("--cache_dir",action="store",type="str",help="local directory to use for file caching",default=os.getenv('HOME',default='.'))

    (opt,args)=parser.parse_args()

    if opt.debug:
        logging.basicConfig(level=logging.DEBUG,format="vofs:%(module)s.%(funcName)s %(message)s",filename='/tmp/vos.err')
        forground=True
    elif opt.verbose:
        logging.basicConfig(level=logging.INFO,format="vofs:%(module)s.%(funcName)s %(message)s",filename='/tmp/vos.err')
    else:
        logging.basicConfig(level=logging.ERROR,format="vofs:%(module)s.%(funcName)s %(message)s",filename='/tmp/vos.err')

    if len(args) != 2:
        parser.error("not enough arguments on the commnad line\n")

    logging.info("Checking for a VO x509 certificate")
    conn=vos.Connection()
    logging.info("Got a certificate")

    root = args[0]
    mount = args[1]
    if not os.access(mount,os.F_OK):
	os.makedirs(mount)
    if platform=="darwin":
        fuse = FUSE(VOFS(root,opt.cache_dir,conn=conn,cache_limit=opt.cache_limit), mount, fsname=root,
                volname=root,
                foreground=opt.foreground,
                noappledouble=True,
                noapplexattr=True)
    else:
        fuse = FUSE(VOFS(root,opt.cache_dir,conn=conn,cache_limit=opt.cache_limit), mount, fsname=root, foreground=opt.foreground)
